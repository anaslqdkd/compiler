section .data
    a dq 7                 ; Constante a = 7 (quad word)
    b dq 2                 ; Constante b = 2
    newline db 0xA         ; Saut de ligne

section .bss
    buffer resb 20         ; Buffer pour conversion ASCII

section .text
    global _start

_start:
    ; --- PUSH des constantes sur la pile ---
    mov rax, [a]
    push rax               ; push a
    mov rbx, [b]
    push rbx               ; push b

    ; === Addition ===
    pop rbx                ; b
    pop rax                ; a
    add rax, rbx
    call print_rax

    ; Remettre a et b sur la pile
    mov rax, [a]
    push rax
    mov rbx, [b]
    push rbx

    ; === Soustraction ===
    pop rbx
    pop rax
    sub rax, rbx
    call print_rax

    ; Remettre a et b sur la pile
    mov rax, [a]
    push rax
    mov rbx, [b]
    push rbx

    ; === Multiplication ===
    pop rbx
    pop rax
    imul rax, rbx
    call print_rax

    ; Remettre a et b sur la pile
    mov rax, [a]
    push rax
    mov rbx, [b]
    push rbx

    ; === Division enti√®re ===
    pop rbx                ; b
    pop rax                ; a
    xor rdx, rdx
    div rbx                ; rax = a // b
    call print_rax

    ; Remettre a et b sur la pile
    mov rax, [a]
    push rax
    mov rbx, [b]
    push rbx

    ; === Modulo ===
    pop rbx
    pop rax
    xor rdx, rdx
    div rbx
    mov rax, rdx           ; rax = a % b
    call print_rax

    ; === Exit ===
    mov rax, 60
    xor rdi, rdi
    syscall

; =============================
; Convert rax en ASCII et print
; =============================
print_rax:
    mov rcx, buffer + 20
    mov rbx, 10

.convert_loop:
    xor rdx, rdx
    div rbx
    add dl, '0'
    dec rcx
    mov [rcx], dl
    test rax, rax
    jnz .convert_loop

    ; write result
    mov rax, 1
    mov rdi, 1
    mov rsi, rcx
    mov rdx, buffer + 20
    sub rdx, rcx
    syscall

    ; newline
    mov rax, 1
    mov rdi, 1
    mov rsi, newline
    mov rdx, 1
    syscall

    ret
